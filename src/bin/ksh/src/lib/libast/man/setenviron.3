.fp 5 CW
.de Af
.ds ;G \\*(;G\\f\\$1\\$3\\f\\$2
.if !\\$4 .Af \\$2 \\$1 "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
..
.de aF
.ie \\$3 .ft \\$1
.el \{\
.ds ;G \&
.nr ;G \\n(.f
.Af "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
\\*(;G
.ft \\n(;G \}
..
.de L
.aF 5 \\n(.f "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7"
..
.de LR
.aF 5 1 "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7"
..
.de RL
.aF 1 5 "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7"
..
.de EX		\" start example
.ta 1i 2i 3i 4i 5i 6i
.PP
.RS 
.PD 0
.ft 5
.nf
..
.de EE		\" end example
.fi
.ft
.PD
.RE
.PP
..
.TH LIBAST 3
.SH NAME
setenviron \- set environment value
.SH SYNOPSIS
.EX
#include <ast.h>

char*     setenviron(const char* \fIkey\fP);
.EE
.SH DESCRIPTION
.L setenviron
controls environment
.I name=value
pairs.
.L setenviron("\fIname=value\fP")
adds
.I name
to the environment and returns a pointer to a
.IR strdup (3)
copy of
.IR name=value .
.L setenviron("\fIname\fP")
removes
.I name
from the environment and returns the empty string.
.L setenviron(0)
reserves a few slots in an internal array and is usually called by
a parent process that expects many children.
0 is returned on error.
.L setenviron
preserves the
.IR ksh (1)
convention of
.L _
as the first environment variable name.
.SH "SEE ALSO"
env(1), exec(2)
.SH BUGS
POSIX will eventually settle on an interface.
It has already picked a few of the names we did in .2 drafts.
This is about the third name change for ours.
