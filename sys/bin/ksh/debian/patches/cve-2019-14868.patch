Description: CVE-2019-14868
 Certain environment variables were interpreted as arithmetic
 expressions on startup, leading to code injection.
Bug-Debian: https://bugs.debian.org/948989
Bug-RedHat: https://bugzilla.redhat.com/show_bug.cgi?id=1757324
Author: Kurtis Rader <krader@skepticism.us>
Origin: https://github.com/ksh93/ksh/commit/593a5a8b7f272c2488c8a800820ae990942946e7
Date: 2020-05-21

diff --git a/src/cmd/ksh93/sh/arith.c b/src/cmd/ksh93/sh/arith.c
index b1059421..6361431b 100644
--- a/src/cmd/ksh93/sh/arith.c
+++ b/src/cmd/ksh93/sh/arith.c
@@ -513,21 +513,36 @@ Sfdouble_t sh_strnum(register const char *str, char** ptr, int mode)
 	char base=(shp->inarith?0:10), *last;
 	if(*str==0)
 	{
-		if(ptr)
-			*ptr = (char*)str;
-		return(0);
-	}
-	errno = 0;
-	d = strtonll(str,&last,&base,-1);
-	if(*last || errno)
-	{
-		if(!last || *last!='.' || last[1]!='.')
-			d = strval(shp,str,&last,arith,mode);
-		if(!ptr && *last && mode>0)
-			errormsg(SH_DICT,ERROR_exit(1),e_lexbadchar,*last,str);
+		d = 0.0;
+		last = (char*)str;
+	} else {
+		errno = 0;
+		d = strtonll(str,&last,&base,-1);
+		if (*last && !shp->inarith && sh_isstate(SH_INIT)) {
+			/* This call is to handle "base#value" literals if we're importing untrusted env vars. */
+			errno = 0;
+			d = strtonll(str, &last, NULL, -1);
+		}
+
+		if(*last || errno)
+		{
+			if (sh_isstate(SH_INIT)) {
+				/*
+				 * Initializing means importing untrusted env vars. The string does not appear to be
+				 * a recognized numeric literal, so give up. We can't safely call strval(), because
+				 * that allows arbitrary expressions, causing security vulnerability CVE-2019-14868.
+				 */
+				d = 0.0;
+			} else {
+				if(!last || *last!='.' || last[1]!='.')
+					d = strval(shp,str,&last,arith,mode);
+				if(!ptr && *last && mode>0)
+					errormsg(SH_DICT,ERROR_exit(1),e_lexbadchar,*last,str);
+			}
+		} else if (!d && *str=='-') {
+			d = -0.0;
+		}
 	}
-	else if (!d && *str=='-')
-		d = -0.0;
 	if(ptr)
 		*ptr = last;
 	return(d);
diff --git a/src/cmd/ksh93/tests/variables.sh b/src/cmd/ksh93/tests/variables.sh
index 6eec31b6..9ceb2d1b 100755
--- a/src/cmd/ksh93/tests/variables.sh
+++ b/src/cmd/ksh93/tests/variables.sh
@@ -674,4 +674,28 @@ level=$($SHELL -c $'$SHELL -c \'print -r "$SHLVL"\'')
 $SHELL -c 'unset .sh' 2> /dev/null
 [[ $? == 1 ]] || err_exit 'unset .sh should return 1'
 
+# ======
+# Verify that importing untrusted environment variables does not allow evaluating
+# arbitrary expressions, but does recognize all integer literals recognized by ksh.
+
+expect=8
+actual=$(env SHLVL='7' "$SHELL" -c 'echo $SHLVL')
+[[ $actual == $expect ]] || err_exit "decimal int literal not recognized (expected '$expect', got '$actual')"
+
+expect=14
+actual=$(env SHLVL='013' "$SHELL" -c 'echo $SHLVL')
+[[ $actual == $expect ]] || err_exit "leading zeros int literal not recognized (expected '$expect', got '$actual')"
+
+expect=4
+actual=$(env SHLVL='2#11' "$SHELL" -c 'echo $SHLVL')
+[[ $actual == $expect ]] || err_exit "base#value int literal not recognized (expected '$expect', got '$actual')"
+
+expect=12
+actual=$(env SHLVL='16#B' "$SHELL" -c 'echo $SHLVL')
+[[ $actual == $expect ]] || err_exit "base#value int literal not recognized (expected '$expect', got '$actual')"
+
+expect=1
+actual=$(env SHLVL="2#11+x[\$(env echo Exploited vuln CVE-2019-14868 >&2)0]" "$SHELL" -c 'echo $SHLVL' 2>&1)
+[[ $actual == $expect ]] || err_exit "expression allowed on env var import (expected '$expect', got '$actual')"
+
 exit $((Errors<125?Errors:125))
